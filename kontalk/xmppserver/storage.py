# -*- coding: utf-8 -*-
"""Storage modules."""
"""
  Kontalk XMPP server
  Copyright (C) 2011 Kontalk Devteam <devteam@kontalk.org>

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


from twisted.enterprise import adbapi
from twisted.words.protocols.jabber import jid

from wokkel import generic

import base64
import util, xmlstream2

dbpool = None

def init(config):
    global dbpool
    dbpool = adbapi.ConnectionPool(config['dbmodule'], host=config['host'], port=config['port'],
        user=config['user'], passwd=config['password'], db=config['dbname'])


""" interfaces """


class StanzaStorage():
    """Stanza storage system."""

    def store(self, stanza):
        """Store a stanza."""
        pass

    def get_by_id(self, stanzaId):
        """Retrieve a stanza by id."""
        pass

    def get_by_sender(self, sender):
        """Retrieve stanzas by sender."""
        pass

    def get_by_recipient(self, recipient):
        """Retrieve stanzas by recipient."""
        pass

    def delete(self, stanzaId):
        """Delete a stanza by id."""
        pass


class PresenceStorage():
    """Presence cache storage."""

    def get(self, user_jid):
        """Retrieve info about a user."""
        pass

    def presence(self, stanza):
        """Persist a presence."""
        pass

    def touch(self, user_jid):
        """Update last seen timestamp of a user."""
        pass


class NetworkStorage():
    """Network info storage."""

    def get_list(self):
        """Retrieve the list of servers in this network."""
        pass



""" implementations """


class MySQLStanzaStorage(StanzaStorage):

    def store(self, stanza):
        global dbpool
        receipt = xmlstream2.extract_receipt(stanza, 'request')
        if receipt:
            # this is indeed generated by server :)
            msgId = receipt['id']
        else:
            # WARNING stanza id must be server generated
            msgId = stanza['id']
        args = (
            msgId,
            util.jid_to_userid(jid.JID(stanza['from'])),
            util.jid_to_userid(jid.JID(stanza['to'])),
            stanza.toXml().encode('utf-8'),
        )
        return dbpool.runOperation('INSERT INTO stanzas (id, sender, recipient, content, timestamp) VALUES(?, ?, ?, ?, UTC_TIMESTAMP())', args)

    def get_by_id(self, stanzaId):
        global dbpool
        def _translate(tx, stanzaId):
            # TODO translation to dict
            tx.execute('SELECT content, timestamp FROM stanzas WHERE id = ?', (stanzaId, ))
            return tx.fetchone()
        return dbpool.runInteraction(_translate, stanzaId)

    def get_by_sender(self, sender):
        # TODO
        #global dbpool
        #return dbpool.runQuery('SELECT id, recipient, content, timestamp FROM stanzas WHERE sender = ?', sender)
        pass

    def get_by_recipient(self, recipient):
        global dbpool
        def _translate(tx, recipient):
            userid, unused = util.jid_to_userid(recipient, True)
            tx.execute('SELECT id, timestamp, content FROM stanzas WHERE recipient = ?', (userid, ))
            data = tx.fetchall()
            out = {}
            for row in data:
                stanzaId = str(row[0])
                d = { 'timestamp': row[1] }
                d['stanza'] = generic.parseXml(row[2].encode('utf-8'))

                """
                Add a <storage/> element to the stanza; this way components have
                a way to know if stanza is coming from storage.
                """
                stor = d['stanza'].addElement((xmlstream2.NS_XMPP_STORAGE, 'storage'))
                stor['id'] = stanzaId

                out[stanzaId] = d
            return out
        return dbpool.runInteraction(_translate, recipient)

    def delete(self, stanzaId):
        global dbpool
        return dbpool.runOperation('DELETE FROM stanzas WHERE id = ?', (stanzaId, ))

class MySQLNetworkStorage(NetworkStorage):

    def get_list(self):
        global dbpool
        def _translate(tx):
            out = {}
            tx.execute('SELECT fingerprint, host FROM servers')
            data = tx.fetchall()
            for row in data:
                # { fingerprint: host }
                out[str(row[0])] = str(row[1])
            return out
        return dbpool.runInteraction(_translate)

class MySQLPresenceStorage(PresenceStorage):

    def get(self, user_jid):
        def _fetchone(tx, query, args):
            tx.execute(query, args)
            data = tx.fetchone()
            if data:
                return {
                    'timestamp': data[0],
                    'status': base64.b64decode(data[1]).decode('utf-8') if data[1] is not None else '',
                    'show': data[2]
                }
        def _fetchall(tx, query, args):
            tx.execute(query, args)
            data = tx.fetchall()
            print data
            out = []
            for d in data:
                out.append({
                    'userid': d[0],
                    'timestamp': d[1],
                    'status': base64.b64decode(d[2]).decode('utf-8') if d[2] is not None else '',
                    'show': d[3]
                })
            return out

        userid = util.jid_to_userid(user_jid)
        if user_jid.resource:
            interaction = _fetchone
            query = 'SELECT `timestamp`, `status`, `show` FROM presence WHERE userid = ?'
        else:
            interaction = _fetchall
            query = 'SELECT `userid`, `timestamp`, `status`, `show` FROM presence WHERE SUBSTR(userid, 1, 40) = ? ORDER BY `timestamp` DESC'

        args = (userid, )
        return dbpool.runInteraction(interaction, query, args)

    def presence(self, stanza):
        global dbpool
        sender = jid.JID(stanza['from'])
        userid = util.jid_to_userid(sender)

        def encode_not_empty(val):
            if val is not None:
                data = val.__str__().encode('utf-8')
                if len(data) > 0:
                    return base64.b64encode(val.__str__().encode('utf-8'))
            return None

        values = (userid, encode_not_empty(stanza.status), util.str_none(stanza.show))
        dbpool.runOperation('REPLACE INTO presence VALUES(?, UTC_TIMESTAMP(), ?, ?)', values)

    def touch(self, user_jid):
        global dbpool
        userid = util.jid_to_userid(user_jid)
        dbpool.runOperation('UPDATE presence SET timestamp = UTC_TIMESTAMP() WHERE userid = ?', (userid, ))
